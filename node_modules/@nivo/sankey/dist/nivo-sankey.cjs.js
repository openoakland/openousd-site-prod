'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var _uniq = _interopDefault(require('lodash/uniq'));
var react = require('react');
var core = require('@nivo/core');
var legends = require('@nivo/legends');
var d3Sankey = require('d3-sankey');
var tooltip = require('@nivo/tooltip');
var jsxRuntime = require('react/jsx-runtime');
var _cloneDeep = _interopDefault(require('lodash/cloneDeep'));
var colors = require('@nivo/colors');
var web = require('@react-spring/web');
var d3Shape = require('d3-shape');

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}

var SankeyNodeTooltip = function SankeyNodeTooltip(_ref) {
  var node = _ref.node;
  return jsxRuntime.jsx(tooltip.BasicTooltip, {
    id: node.label,
    enableChip: true,
    color: node.color
  });
};

var tooltipStyles = {
  container: {
    display: 'flex',
    alignItems: 'center'
  },
  sourceChip: {
    marginRight: 7
  },
  targetChip: {
    marginLeft: 7,
    marginRight: 7
  }
};
var SankeyLinkTooltip = function SankeyLinkTooltip(_ref) {
  var link = _ref.link;
  return jsxRuntime.jsx(tooltip.BasicTooltip, {
    id: jsxRuntime.jsxs("span", {
      style: tooltipStyles.container,
      children: [jsxRuntime.jsx(tooltip.Chip, {
        color: link.source.color,
        style: tooltipStyles.sourceChip
      }), jsxRuntime.jsx("strong", {
        children: link.source.label
      }), ' > ', jsxRuntime.jsx("strong", {
        children: link.target.label
      }), jsxRuntime.jsx(tooltip.Chip, {
        color: link.target.color,
        style: tooltipStyles.targetChip
      }), jsxRuntime.jsx("strong", {
        children: link.formattedValue
      })]
    })
  });
};

var sankeyAlignmentPropMapping = {
  center: d3Sankey.sankeyCenter,
  justify: d3Sankey.sankeyJustify,
  start: d3Sankey.sankeyLeft,
  end: d3Sankey.sankeyRight
};
var sankeyAlignmentPropKeys = Object.keys(sankeyAlignmentPropMapping);
var sankeyAlignmentFromProp = function sankeyAlignmentFromProp(prop) {
  return sankeyAlignmentPropMapping[prop];
};
var svgDefaultProps = {
  layout: 'horizontal',
  align: 'center',
  sort: 'auto',
  colors: {
    scheme: 'nivo'
  },
  nodeOpacity: 0.75,
  nodeHoverOpacity: 1,
  nodeHoverOthersOpacity: 0.15,
  nodeThickness: 12,
  nodeSpacing: 12,
  nodeInnerPadding: 0,
  nodeBorderWidth: 1,
  nodeBorderColor: {
    from: 'color',
    modifiers: [['darker', 0.5]]
  },
  nodeBorderRadius: 0,
  linkOpacity: 0.25,
  linkHoverOpacity: 0.6,
  linkHoverOthersOpacity: 0.15,
  linkContract: 0,
  linkBlendMode: 'multiply',
  enableLinkGradient: false,
  enableLabels: true,
  label: 'id',
  labelPosition: 'inside',
  labelPadding: 9,
  labelOrientation: 'horizontal',
  labelTextColor: {
    from: 'color',
    modifiers: [['darker', 0.8]]
  },
  isInteractive: true,
  nodeTooltip: SankeyNodeTooltip,
  linkTooltip: SankeyLinkTooltip,
  legends: [],
  layers: ['links', 'nodes', 'labels', 'legends'],
  role: 'img',
  animate: true,
  motionConfig: 'gentle'
};

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;
  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }
  return _arr;
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

var getId = function getId(node) {
  return node.id;
};

var computeNodeAndLinks = function computeNodeAndLinks(_ref) {
  var _data = _ref.data,
      formatValue = _ref.formatValue,
      layout = _ref.layout,
      alignFunction = _ref.alignFunction,
      sortFunction = _ref.sortFunction,
      linkSortMode = _ref.linkSortMode,
      nodeThickness = _ref.nodeThickness,
      nodeSpacing = _ref.nodeSpacing,
      nodeInnerPadding = _ref.nodeInnerPadding,
      width = _ref.width,
      height = _ref.height,
      getColor = _ref.getColor,
      getLabel = _ref.getLabel;
  var sankey = d3Sankey.sankey().nodeAlign(alignFunction).nodeSort(sortFunction).linkSort(linkSortMode).nodeWidth(nodeThickness).nodePadding(nodeSpacing).size(layout === 'horizontal' ? [width, height] : [height, width]).nodeId(getId);

  var data = _cloneDeep(_data);

  sankey(data);
  data.nodes.forEach(function (node) {
    node.color = getColor(node);
    node.label = getLabel(node);
    node.formattedValue = formatValue(node.value);

    if (layout === 'horizontal') {
      node.x = node.x0 + nodeInnerPadding;
      node.y = node.y0;
      node.width = Math.max(node.x1 - node.x0 - nodeInnerPadding * 2, 0);
      node.height = Math.max(node.y1 - node.y0, 0);
    } else {
      node.x = node.y0;
      node.y = node.x0 + nodeInnerPadding;
      node.width = Math.max(node.y1 - node.y0, 0);
      node.height = Math.max(node.x1 - node.x0 - nodeInnerPadding * 2, 0);
      var oldX0 = node.x0;
      var oldX1 = node.x1;
      node.x0 = node.y0;
      node.x1 = node.y1;
      node.y0 = oldX0;
      node.y1 = oldX1;
    }
  });
  data.links.forEach(function (link) {
    link.formattedValue = formatValue(link.value);
    link.color = link.source.color;
    link.pos0 = link.y0;
    link.pos1 = link.y1;
    link.thickness = link.width;
    delete link.y0;
    delete link.y1;
    delete link.width;
  });
  return data;
};
var useSankey = function useSankey(_ref2) {
  var data = _ref2.data,
      valueFormat = _ref2.valueFormat,
      layout = _ref2.layout,
      width = _ref2.width,
      height = _ref2.height,
      sort = _ref2.sort,
      align = _ref2.align,
      colors$1 = _ref2.colors,
      nodeThickness = _ref2.nodeThickness,
      nodeSpacing = _ref2.nodeSpacing,
      nodeInnerPadding = _ref2.nodeInnerPadding,
      nodeBorderColor = _ref2.nodeBorderColor,
      label = _ref2.label,
      labelTextColor = _ref2.labelTextColor;

  var _useState = react.useState(null),
      _useState2 = _slicedToArray(_useState, 2),
      currentNode = _useState2[0],
      setCurrentNode = _useState2[1];

  var _useState3 = react.useState(null),
      _useState4 = _slicedToArray(_useState3, 2),
      currentLink = _useState4[0],
      setCurrentLink = _useState4[1];

  var sortFunction = react.useMemo(function () {
    if (sort === 'auto') return undefined;
    if (sort === 'input') return null;

    if (sort === 'ascending') {
      return function (a, b) {
        return a.value - b.value;
      };
    }

    if (sort === 'descending') {
      return function (a, b) {
        return b.value - a.value;
      };
    }

    return sort;
  }, [sort]);
  var linkSortMode = sort === 'input' ? null : undefined;
  var alignFunction = react.useMemo(function () {
    if (typeof align === 'function') return align;
    return sankeyAlignmentFromProp(align);
  }, [align]);
  var theme = core.useTheme();
  var getColor = colors.useOrdinalColorScale(colors$1, 'id');
  var getNodeBorderColor = colors.useInheritedColor(nodeBorderColor, theme);
  var getLabel = core.usePropertyAccessor(label);
  var getLabelTextColor = colors.useInheritedColor(labelTextColor, theme);
  var formatValue = core.useValueFormatter(valueFormat);

  var _useMemo = react.useMemo(function () {
    return computeNodeAndLinks({
      data: data,
      formatValue: formatValue,
      layout: layout,
      alignFunction: alignFunction,
      sortFunction: sortFunction,
      linkSortMode: linkSortMode,
      nodeThickness: nodeThickness,
      nodeSpacing: nodeSpacing,
      nodeInnerPadding: nodeInnerPadding,
      width: width,
      height: height,
      getColor: getColor,
      getLabel: getLabel
    });
  }, [data, formatValue, layout, alignFunction, sortFunction, linkSortMode, nodeThickness, nodeSpacing, nodeInnerPadding, width, height, getColor, getLabel]),
      nodes = _useMemo.nodes,
      links = _useMemo.links;

  var legendData = react.useMemo(function () {
    return nodes.map(function (node) {
      return {
        id: node.id,
        label: node.label,
        color: node.color
      };
    });
  }, [nodes]);
  return {
    nodes: nodes,
    links: links,
    legendData: legendData,
    getNodeBorderColor: getNodeBorderColor,
    currentNode: currentNode,
    setCurrentNode: setCurrentNode,
    currentLink: currentLink,
    setCurrentLink: setCurrentLink,
    getLabelTextColor: getLabelTextColor
  };
};

var SankeyNodesItem = function SankeyNodesItem(_ref) {
  var node = _ref.node,
      x = _ref.x,
      y = _ref.y,
      width = _ref.width,
      height = _ref.height,
      color = _ref.color,
      opacity = _ref.opacity,
      borderWidth = _ref.borderWidth,
      borderColor = _ref.borderColor,
      borderRadius = _ref.borderRadius,
      setCurrent = _ref.setCurrent,
      isInteractive = _ref.isInteractive,
      onClick = _ref.onClick,
      tooltip$1 = _ref.tooltip;

  var _useMotionConfig = core.useMotionConfig(),
      animate = _useMotionConfig.animate,
      springConfig = _useMotionConfig.config;

  var animatedProps = web.useSpring({
    x: x,
    y: y,
    width: width,
    height: height,
    opacity: opacity,
    color: color,
    config: springConfig,
    immediate: !animate
  });

  var _useTooltip = tooltip.useTooltip(),
      showTooltipFromEvent = _useTooltip.showTooltipFromEvent,
      hideTooltip = _useTooltip.hideTooltip;

  var handleMouseEnter = react.useCallback(function (event) {
    setCurrent(node);
    showTooltipFromEvent(react.createElement(tooltip$1, {
      node: node
    }), event, 'left');
  }, [setCurrent, node, showTooltipFromEvent, tooltip$1]);
  var handleMouseMove = react.useCallback(function (event) {
    showTooltipFromEvent(react.createElement(tooltip$1, {
      node: node
    }), event, 'left');
  }, [showTooltipFromEvent, node, tooltip$1]);
  var handleMouseLeave = react.useCallback(function () {
    setCurrent(null);
    hideTooltip();
  }, [setCurrent, hideTooltip]);
  var handleClick = react.useCallback(function (event) {
    onClick === null || onClick === void 0 ? void 0 : onClick(node, event);
  }, [onClick, node]);
  return jsxRuntime.jsx(web.animated.rect, {
    x: animatedProps.x,
    y: animatedProps.y,
    rx: borderRadius,
    ry: borderRadius,
    width: animatedProps.width.to(function (v) {
      return Math.max(v, 0);
    }),
    height: animatedProps.height.to(function (v) {
      return Math.max(v, 0);
    }),
    fill: animatedProps.color,
    fillOpacity: animatedProps.opacity,
    strokeWidth: borderWidth,
    stroke: borderColor,
    strokeOpacity: opacity,
    onMouseEnter: isInteractive ? handleMouseEnter : undefined,
    onMouseMove: isInteractive ? handleMouseMove : undefined,
    onMouseLeave: isInteractive ? handleMouseLeave : undefined,
    onClick: isInteractive ? handleClick : undefined
  });
};

var SankeyNodes = function SankeyNodes(_ref) {
  var nodes = _ref.nodes,
      nodeOpacity = _ref.nodeOpacity,
      nodeHoverOpacity = _ref.nodeHoverOpacity,
      nodeHoverOthersOpacity = _ref.nodeHoverOthersOpacity,
      borderWidth = _ref.borderWidth,
      getBorderColor = _ref.getBorderColor,
      borderRadius = _ref.borderRadius,
      setCurrentNode = _ref.setCurrentNode,
      currentNode = _ref.currentNode,
      currentLink = _ref.currentLink,
      isCurrentNode = _ref.isCurrentNode,
      isInteractive = _ref.isInteractive,
      onClick = _ref.onClick,
      tooltip = _ref.tooltip;

  var getOpacity = function getOpacity(node) {
    if (!currentNode && !currentLink) return nodeOpacity;
    if (isCurrentNode(node)) return nodeHoverOpacity;
    return nodeHoverOthersOpacity;
  };

  return jsxRuntime.jsx(jsxRuntime.Fragment, {
    children: nodes.map(function (node) {
      return jsxRuntime.jsx(SankeyNodesItem, {
        node: node,
        x: node.x,
        y: node.y,
        width: node.width,
        height: node.height,
        color: node.color,
        opacity: getOpacity(node),
        borderWidth: borderWidth,
        borderColor: getBorderColor(node),
        borderRadius: borderRadius,
        setCurrent: setCurrentNode,
        isInteractive: isInteractive,
        onClick: onClick,
        tooltip: tooltip
      }, node.id);
    })
  });
};

var sankeyLinkHorizontal = function sankeyLinkHorizontal() {
  var lineGenerator = d3Shape.line().curve(d3Shape.curveMonotoneX);
  return function (link, contract) {
    var thickness = Math.max(1, link.thickness - contract * 2);
    var halfThickness = thickness / 2;
    var linkLength = link.target.x0 - link.source.x1;
    var padLength = linkLength * 0.12;
    var dots = [[link.source.x1, link.pos0 - halfThickness], [link.source.x1 + padLength, link.pos0 - halfThickness], [link.target.x0 - padLength, link.pos1 - halfThickness], [link.target.x0, link.pos1 - halfThickness], [link.target.x0, link.pos1 + halfThickness], [link.target.x0 - padLength, link.pos1 + halfThickness], [link.source.x1 + padLength, link.pos0 + halfThickness], [link.source.x1, link.pos0 + halfThickness], [link.source.x1, link.pos0 - halfThickness]];
    return lineGenerator(dots) + 'Z';
  };
};
var sankeyLinkVertical = function sankeyLinkVertical() {
  var lineGenerator = d3Shape.line().curve(d3Shape.curveMonotoneY);
  return function (link, contract) {
    var thickness = Math.max(1, link.thickness - contract * 2);
    var halfThickness = thickness / 2;
    var linkLength = link.target.y0 - link.source.y1;
    var padLength = linkLength * 0.12;
    var dots = [[link.pos0 + halfThickness, link.source.y1], [link.pos0 + halfThickness, link.source.y1 + padLength], [link.pos1 + halfThickness, link.target.y0 - padLength], [link.pos1 + halfThickness, link.target.y0], [link.pos1 - halfThickness, link.target.y0], [link.pos1 - halfThickness, link.target.y0 - padLength], [link.pos0 - halfThickness, link.source.y1 + padLength], [link.pos0 - halfThickness, link.source.y1], [link.pos0 + halfThickness, link.source.y1]];
    return lineGenerator(dots) + 'Z';
  };
};

var SankeyLinkGradient = function SankeyLinkGradient(_ref) {
  var id = _ref.id,
      layout = _ref.layout,
      startColor = _ref.startColor,
      endColor = _ref.endColor;
  var gradientProps;

  if (layout === 'horizontal') {
    gradientProps = {
      x1: '0%',
      x2: '100%',
      y1: '0%',
      y2: '0%'
    };
  } else {
    gradientProps = {
      x1: '0%',
      x2: '0%',
      y1: '0%',
      y2: '100%'
    };
  }

  return jsxRuntime.jsxs("linearGradient", _objectSpread2(_objectSpread2({
    id: id,
    spreadMethod: "pad"
  }, gradientProps), {}, {
    children: [jsxRuntime.jsx("stop", {
      offset: "0%",
      stopColor: startColor
    }), jsxRuntime.jsx("stop", {
      offset: "100%",
      stopColor: endColor
    })]
  }));
};

var SankeyLinksItem = function SankeyLinksItem(_ref) {
  var link = _ref.link,
      layout = _ref.layout,
      path = _ref.path,
      color = _ref.color,
      opacity = _ref.opacity,
      blendMode = _ref.blendMode,
      enableGradient = _ref.enableGradient,
      setCurrent = _ref.setCurrent,
      tooltip$1 = _ref.tooltip,
      isInteractive = _ref.isInteractive,
      onClick = _ref.onClick;
  var linkId = "".concat(link.source.id, ".").concat(link.target.id);

  var _useMotionConfig = core.useMotionConfig(),
      animate = _useMotionConfig.animate,
      springConfig = _useMotionConfig.config;

  var animatedPath = core.useAnimatedPath(path);
  var animatedProps = web.useSpring({
    color: color,
    opacity: opacity,
    config: springConfig,
    immediate: !animate
  });

  var _useTooltip = tooltip.useTooltip(),
      showTooltipFromEvent = _useTooltip.showTooltipFromEvent,
      hideTooltip = _useTooltip.hideTooltip;

  var handleMouseEnter = react.useCallback(function (event) {
    setCurrent(link);
    showTooltipFromEvent(react.createElement(tooltip$1, {
      link: link
    }), event, 'left');
  }, [setCurrent, link, showTooltipFromEvent, tooltip$1]);
  var handleMouseMove = react.useCallback(function (event) {
    showTooltipFromEvent(react.createElement(tooltip$1, {
      link: link
    }), event, 'left');
  }, [showTooltipFromEvent, link, tooltip$1]);
  var handleMouseLeave = react.useCallback(function () {
    setCurrent(null);
    hideTooltip();
  }, [setCurrent, hideTooltip]);
  var handleClick = react.useCallback(function (event) {
    onClick === null || onClick === void 0 ? void 0 : onClick(link, event);
  }, [onClick, link]);
  return jsxRuntime.jsxs(jsxRuntime.Fragment, {
    children: [enableGradient && jsxRuntime.jsx(SankeyLinkGradient, {
      id: linkId,
      layout: layout,
      startColor: link.startColor || link.source.color,
      endColor: link.endColor || link.target.color
    }), jsxRuntime.jsx(web.animated.path, {
      fill: enableGradient ? "url(\"#".concat(encodeURI(linkId), "\")") : animatedProps.color,
      d: animatedPath,
      fillOpacity: animatedProps.opacity,
      onMouseEnter: isInteractive ? handleMouseEnter : undefined,
      onMouseMove: isInteractive ? handleMouseMove : undefined,
      onMouseLeave: isInteractive ? handleMouseLeave : undefined,
      onClick: isInteractive ? handleClick : undefined,
      style: {
        mixBlendMode: blendMode
      }
    })]
  });
};

var SankeyLinks = function SankeyLinks(_ref) {
  var links = _ref.links,
      layout = _ref.layout,
      linkOpacity = _ref.linkOpacity,
      linkHoverOpacity = _ref.linkHoverOpacity,
      linkHoverOthersOpacity = _ref.linkHoverOthersOpacity,
      linkContract = _ref.linkContract,
      linkBlendMode = _ref.linkBlendMode,
      enableLinkGradient = _ref.enableLinkGradient,
      setCurrentLink = _ref.setCurrentLink,
      currentLink = _ref.currentLink,
      currentNode = _ref.currentNode,
      isCurrentLink = _ref.isCurrentLink,
      isInteractive = _ref.isInteractive,
      onClick = _ref.onClick,
      tooltip = _ref.tooltip;

  var getOpacity = function getOpacity(link) {
    if (!currentNode && !currentLink) return linkOpacity;
    if (isCurrentLink(link)) return linkHoverOpacity;
    return linkHoverOthersOpacity;
  };

  var getLinkPath = react.useMemo(function () {
    return layout === 'horizontal' ? sankeyLinkHorizontal() : sankeyLinkVertical();
  }, [layout]);
  return jsxRuntime.jsx(jsxRuntime.Fragment, {
    children: links.map(function (link) {
      return jsxRuntime.jsx(SankeyLinksItem, {
        link: link,
        layout: layout,
        path: getLinkPath(link, linkContract),
        color: link.color,
        opacity: getOpacity(link),
        blendMode: linkBlendMode,
        enableGradient: enableLinkGradient,
        setCurrent: setCurrentLink,
        isInteractive: isInteractive,
        onClick: onClick,
        tooltip: tooltip
      }, "".concat(link.source.id, ".").concat(link.target.id));
    })
  });
};

var SankeyLabels = function SankeyLabels(_ref) {
  var nodes = _ref.nodes,
      layout = _ref.layout,
      width = _ref.width,
      height = _ref.height,
      labelPosition = _ref.labelPosition,
      labelPadding = _ref.labelPadding,
      labelOrientation = _ref.labelOrientation,
      getLabelTextColor = _ref.getLabelTextColor;
  var theme = core.useTheme();
  var labelRotation = labelOrientation === 'vertical' ? -90 : 0;
  var labels = nodes.map(function (node) {
    var x;
    var y;
    var textAnchor;

    if (layout === 'horizontal') {
      y = node.y + node.height / 2;

      if (node.x < width / 2) {
        if (labelPosition === 'inside') {
          x = node.x1 + labelPadding;
          textAnchor = labelOrientation === 'vertical' ? 'middle' : 'start';
        } else {
          x = node.x - labelPadding;
          textAnchor = labelOrientation === 'vertical' ? 'middle' : 'end';
        }
      } else {
        if (labelPosition === 'inside') {
          x = node.x - labelPadding;
          textAnchor = labelOrientation === 'vertical' ? 'middle' : 'end';
        } else {
          x = node.x1 + labelPadding;
          textAnchor = labelOrientation === 'vertical' ? 'middle' : 'start';
        }
      }
    } else if (layout === 'vertical') {
      x = node.x + node.width / 2;

      if (node.y < height / 2) {
        if (labelPosition === 'inside') {
          y = node.y1 + labelPadding;
          textAnchor = labelOrientation === 'vertical' ? 'end' : 'middle';
        } else {
          y = node.y - labelPadding;
          textAnchor = labelOrientation === 'vertical' ? 'start' : 'middle';
        }
      } else {
        if (labelPosition === 'inside') {
          y = node.y - labelPadding;
          textAnchor = labelOrientation === 'vertical' ? 'start' : 'middle';
        } else {
          y = node.y1 + labelPadding;
          textAnchor = labelOrientation === 'vertical' ? 'end' : 'middle';
        }
      }
    }

    return {
      id: node.id,
      label: node.label,
      x: x,
      y: y,
      textAnchor: textAnchor,
      color: getLabelTextColor(node)
    };
  });

  var _useMotionConfig = core.useMotionConfig(),
      animate = _useMotionConfig.animate,
      springConfig = _useMotionConfig.config;

  var springs = web.useSprings(labels.length, labels.map(function (label) {
    return {
      transform: "translate(".concat(label.x, ", ").concat(label.y, ") rotate(").concat(labelRotation, ")"),
      color: label.color,
      config: springConfig,
      immediate: !animate
    };
  }));
  return jsxRuntime.jsx(jsxRuntime.Fragment, {
    children: springs.map(function (animatedProps, index) {
      var label = labels[index];
      return jsxRuntime.jsx(web.animated.text, {
        dominantBaseline: "central",
        textAnchor: label.textAnchor,
        transform: animatedProps.transform,
        style: _objectSpread2(_objectSpread2({}, theme.labels.text), {}, {
          fill: animatedProps.color,
          pointerEvents: 'none'
        }),
        children: label.label
      }, label.id);
    })
  });
};

var InnerSankey = function InnerSankey(_ref) {
  var data = _ref.data,
      valueFormat = _ref.valueFormat,
      _ref$layout = _ref.layout,
      layout = _ref$layout === void 0 ? svgDefaultProps.layout : _ref$layout,
      _ref$sort = _ref.sort,
      sort = _ref$sort === void 0 ? svgDefaultProps.sort : _ref$sort,
      _ref$align = _ref.align,
      align = _ref$align === void 0 ? svgDefaultProps.align : _ref$align,
      width = _ref.width,
      height = _ref.height,
      partialMargin = _ref.margin,
      _ref$colors = _ref.colors,
      colors = _ref$colors === void 0 ? svgDefaultProps.colors : _ref$colors,
      _ref$nodeThickness = _ref.nodeThickness,
      nodeThickness = _ref$nodeThickness === void 0 ? svgDefaultProps.nodeThickness : _ref$nodeThickness,
      _ref$nodeSpacing = _ref.nodeSpacing,
      nodeSpacing = _ref$nodeSpacing === void 0 ? svgDefaultProps.nodeThickness : _ref$nodeSpacing,
      _ref$nodeInnerPadding = _ref.nodeInnerPadding,
      nodeInnerPadding = _ref$nodeInnerPadding === void 0 ? svgDefaultProps.nodeInnerPadding : _ref$nodeInnerPadding,
      _ref$nodeBorderColor = _ref.nodeBorderColor,
      nodeBorderColor = _ref$nodeBorderColor === void 0 ? svgDefaultProps.nodeBorderColor : _ref$nodeBorderColor,
      _ref$nodeOpacity = _ref.nodeOpacity,
      nodeOpacity = _ref$nodeOpacity === void 0 ? svgDefaultProps.nodeOpacity : _ref$nodeOpacity,
      _ref$nodeHoverOpacity = _ref.nodeHoverOpacity,
      nodeHoverOpacity = _ref$nodeHoverOpacity === void 0 ? svgDefaultProps.nodeHoverOpacity : _ref$nodeHoverOpacity,
      _ref$nodeHoverOthersO = _ref.nodeHoverOthersOpacity,
      nodeHoverOthersOpacity = _ref$nodeHoverOthersO === void 0 ? svgDefaultProps.nodeHoverOthersOpacity : _ref$nodeHoverOthersO,
      _ref$nodeBorderWidth = _ref.nodeBorderWidth,
      nodeBorderWidth = _ref$nodeBorderWidth === void 0 ? svgDefaultProps.nodeBorderWidth : _ref$nodeBorderWidth,
      _ref$nodeBorderRadius = _ref.nodeBorderRadius,
      nodeBorderRadius = _ref$nodeBorderRadius === void 0 ? svgDefaultProps.nodeBorderRadius : _ref$nodeBorderRadius,
      _ref$linkOpacity = _ref.linkOpacity,
      linkOpacity = _ref$linkOpacity === void 0 ? svgDefaultProps.linkOpacity : _ref$linkOpacity,
      _ref$linkHoverOpacity = _ref.linkHoverOpacity,
      linkHoverOpacity = _ref$linkHoverOpacity === void 0 ? svgDefaultProps.linkHoverOpacity : _ref$linkHoverOpacity,
      _ref$linkHoverOthersO = _ref.linkHoverOthersOpacity,
      linkHoverOthersOpacity = _ref$linkHoverOthersO === void 0 ? svgDefaultProps.linkHoverOthersOpacity : _ref$linkHoverOthersO,
      _ref$linkContract = _ref.linkContract,
      linkContract = _ref$linkContract === void 0 ? svgDefaultProps.linkContract : _ref$linkContract,
      _ref$linkBlendMode = _ref.linkBlendMode,
      linkBlendMode = _ref$linkBlendMode === void 0 ? svgDefaultProps.linkBlendMode : _ref$linkBlendMode,
      _ref$enableLinkGradie = _ref.enableLinkGradient,
      enableLinkGradient = _ref$enableLinkGradie === void 0 ? svgDefaultProps.enableLinkGradient : _ref$enableLinkGradie,
      _ref$enableLabels = _ref.enableLabels,
      enableLabels = _ref$enableLabels === void 0 ? svgDefaultProps.enableLabels : _ref$enableLabels,
      _ref$labelPosition = _ref.labelPosition,
      labelPosition = _ref$labelPosition === void 0 ? svgDefaultProps.labelPosition : _ref$labelPosition,
      _ref$labelPadding = _ref.labelPadding,
      labelPadding = _ref$labelPadding === void 0 ? svgDefaultProps.labelPadding : _ref$labelPadding,
      _ref$labelOrientation = _ref.labelOrientation,
      labelOrientation = _ref$labelOrientation === void 0 ? svgDefaultProps.labelOrientation : _ref$labelOrientation,
      _ref$label = _ref.label,
      label = _ref$label === void 0 ? svgDefaultProps.label : _ref$label,
      _ref$labelTextColor = _ref.labelTextColor,
      labelTextColor = _ref$labelTextColor === void 0 ? svgDefaultProps.labelTextColor : _ref$labelTextColor,
      _ref$nodeTooltip = _ref.nodeTooltip,
      nodeTooltip = _ref$nodeTooltip === void 0 ? svgDefaultProps.nodeTooltip : _ref$nodeTooltip,
      _ref$linkTooltip = _ref.linkTooltip,
      linkTooltip = _ref$linkTooltip === void 0 ? svgDefaultProps.linkTooltip : _ref$linkTooltip,
      _ref$isInteractive = _ref.isInteractive,
      isInteractive = _ref$isInteractive === void 0 ? svgDefaultProps.isInteractive : _ref$isInteractive,
      onClick = _ref.onClick,
      _ref$legends = _ref.legends,
      legends$1 = _ref$legends === void 0 ? svgDefaultProps.legends : _ref$legends,
      _ref$layers = _ref.layers,
      layers = _ref$layers === void 0 ? svgDefaultProps.layers : _ref$layers,
      _ref$role = _ref.role,
      role = _ref$role === void 0 ? svgDefaultProps.role : _ref$role,
      ariaLabel = _ref.ariaLabel,
      ariaLabelledBy = _ref.ariaLabelledBy,
      ariaDescribedBy = _ref.ariaDescribedBy;

  var _useDimensions = core.useDimensions(width, height, partialMargin),
      margin = _useDimensions.margin,
      innerWidth = _useDimensions.innerWidth,
      innerHeight = _useDimensions.innerHeight,
      outerWidth = _useDimensions.outerWidth,
      outerHeight = _useDimensions.outerHeight;

  var _useSankey = useSankey({
    data: data,
    valueFormat: valueFormat,
    layout: layout,
    width: innerWidth,
    height: innerHeight,
    sort: sort,
    align: align,
    colors: colors,
    nodeThickness: nodeThickness,
    nodeSpacing: nodeSpacing,
    nodeInnerPadding: nodeInnerPadding,
    nodeBorderColor: nodeBorderColor,
    label: label,
    labelTextColor: labelTextColor
  }),
      nodes = _useSankey.nodes,
      links = _useSankey.links,
      legendData = _useSankey.legendData,
      getNodeBorderColor = _useSankey.getNodeBorderColor,
      currentNode = _useSankey.currentNode,
      setCurrentNode = _useSankey.setCurrentNode,
      currentLink = _useSankey.currentLink,
      setCurrentLink = _useSankey.setCurrentLink,
      getLabelTextColor = _useSankey.getLabelTextColor;

  var isCurrentNode = function isCurrentNode() {
    return false;
  };

  var isCurrentLink = function isCurrentLink() {
    return false;
  };

  if (currentLink) {
    isCurrentNode = function isCurrentNode(_ref2) {
      var id = _ref2.id;
      return id === currentLink.source.id || id === currentLink.target.id;
    };

    isCurrentLink = function isCurrentLink(_ref3) {
      var source = _ref3.source,
          target = _ref3.target;
      return source.id === currentLink.source.id && target.id === currentLink.target.id;
    };
  }

  if (currentNode) {
    var currentNodeIds = [currentNode.id];
    links.filter(function (_ref4) {
      var source = _ref4.source,
          target = _ref4.target;
      return source.id === currentNode.id || target.id === currentNode.id;
    }).forEach(function (_ref5) {
      var source = _ref5.source,
          target = _ref5.target;
      currentNodeIds.push(source.id);
      currentNodeIds.push(target.id);
    });
    currentNodeIds = _uniq(currentNodeIds);

    isCurrentNode = function isCurrentNode(_ref6) {
      var id = _ref6.id;
      return currentNodeIds.includes(id);
    };

    isCurrentLink = function isCurrentLink(_ref7) {
      var source = _ref7.source,
          target = _ref7.target;
      return source.id === currentNode.id || target.id === currentNode.id;
    };
  }

  var layerProps = {
    links: links,
    nodes: nodes,
    margin: margin,
    width: width,
    height: height,
    outerWidth: outerWidth,
    outerHeight: outerHeight
  };
  var layerById = {
    links: null,
    nodes: null,
    labels: null,
    legends: null
  };

  if (layers.includes('links')) {
    layerById.links = jsxRuntime.jsx(SankeyLinks, {
      links: links,
      layout: layout,
      linkContract: linkContract,
      linkOpacity: linkOpacity,
      linkHoverOpacity: linkHoverOpacity,
      linkHoverOthersOpacity: linkHoverOthersOpacity,
      linkBlendMode: linkBlendMode,
      enableLinkGradient: enableLinkGradient,
      setCurrentLink: setCurrentLink,
      currentNode: currentNode,
      currentLink: currentLink,
      isCurrentLink: isCurrentLink,
      isInteractive: isInteractive,
      onClick: onClick,
      tooltip: linkTooltip
    }, "links");
  }

  if (layers.includes('nodes')) {
    layerById.nodes = jsxRuntime.jsx(SankeyNodes, {
      nodes: nodes,
      nodeOpacity: nodeOpacity,
      nodeHoverOpacity: nodeHoverOpacity,
      nodeHoverOthersOpacity: nodeHoverOthersOpacity,
      borderWidth: nodeBorderWidth,
      borderRadius: nodeBorderRadius,
      getBorderColor: getNodeBorderColor,
      setCurrentNode: setCurrentNode,
      currentNode: currentNode,
      currentLink: currentLink,
      isCurrentNode: isCurrentNode,
      isInteractive: isInteractive,
      onClick: onClick,
      tooltip: nodeTooltip
    }, "nodes");
  }

  if (layers.includes('labels') && enableLabels) {
    layerById.labels = jsxRuntime.jsx(SankeyLabels, {
      nodes: nodes,
      layout: layout,
      width: innerWidth,
      height: innerHeight,
      labelPosition: labelPosition,
      labelPadding: labelPadding,
      labelOrientation: labelOrientation,
      getLabelTextColor: getLabelTextColor
    }, "labels");
  }

  if (layers.includes('legends')) {
    layerById.legends = jsxRuntime.jsx(react.Fragment, {
      children: legends$1.map(function (legend, i) {
        return jsxRuntime.jsx(legends.BoxLegendSvg, _objectSpread2(_objectSpread2({}, legend), {}, {
          containerWidth: innerWidth,
          containerHeight: innerHeight,
          data: legendData
        }), "legend".concat(i));
      })
    }, "legends");
  }

  return jsxRuntime.jsx(core.SvgWrapper, {
    width: outerWidth,
    height: outerHeight,
    margin: margin,
    role: role,
    ariaLabel: ariaLabel,
    ariaLabelledBy: ariaLabelledBy,
    ariaDescribedBy: ariaDescribedBy,
    children: layers.map(function (layer, i) {
      var _layerById$layer;

      if (typeof layer === 'function') {
        return jsxRuntime.jsx(react.Fragment, {
          children: react.createElement(layer, layerProps)
        }, i);
      }

      return (_layerById$layer = layerById === null || layerById === void 0 ? void 0 : layerById[layer]) !== null && _layerById$layer !== void 0 ? _layerById$layer : null;
    })
  });
};

var Sankey = function Sankey(_ref8) {
  var _ref8$isInteractive = _ref8.isInteractive,
      isInteractive = _ref8$isInteractive === void 0 ? svgDefaultProps.isInteractive : _ref8$isInteractive,
      _ref8$animate = _ref8.animate,
      animate = _ref8$animate === void 0 ? svgDefaultProps.animate : _ref8$animate,
      _ref8$motionConfig = _ref8.motionConfig,
      motionConfig = _ref8$motionConfig === void 0 ? svgDefaultProps.motionConfig : _ref8$motionConfig,
      theme = _ref8.theme,
      renderWrapper = _ref8.renderWrapper,
      otherProps = _objectWithoutProperties(_ref8, ["isInteractive", "animate", "motionConfig", "theme", "renderWrapper"]);

  return jsxRuntime.jsx(core.Container, {
    animate: animate,
    isInteractive: isInteractive,
    motionConfig: motionConfig,
    renderWrapper: renderWrapper,
    theme: theme,
    children: jsxRuntime.jsx(InnerSankey, _objectSpread2({
      isInteractive: isInteractive
    }, otherProps))
  });
};

var ResponsiveSankey = function ResponsiveSankey(props) {
  return jsxRuntime.jsx(core.ResponsiveWrapper, {
    children: function children(_ref) {
      var width = _ref.width,
          height = _ref.height;
      return jsxRuntime.jsx(Sankey, _objectSpread2({
        width: width,
        height: height
      }, props));
    }
  });
};

exports.ResponsiveSankey = ResponsiveSankey;
exports.Sankey = Sankey;
exports.sankeyAlignmentFromProp = sankeyAlignmentFromProp;
exports.sankeyAlignmentPropKeys = sankeyAlignmentPropKeys;
exports.sankeyAlignmentPropMapping = sankeyAlignmentPropMapping;
exports.svgDefaultProps = svgDefaultProps;
//# sourceMappingURL=nivo-sankey.cjs.js.map
